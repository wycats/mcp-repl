use std::any::type_name;

use anyhow::{Error, Result};
use indexmap::IndexMap;
use pretty::termcolor::ColorSpec;
use pretty::{DocAllocator, docs};
use reedline_repl_rs::clap::{Arg, ArgMatches, Command};
use reedline_repl_rs::yansi::{self, Paint, Painted};
use reedline_repl_rs::{self, Repl};
use schemars::schema::{self, InstanceType, Schema, SchemaObject, SingleOrVec};

use serde_json::Value;
use termimad::crossterm::style::{Attribute, Color, ResetColor};
use termimad::*;

mod pretty_printer;
use pretty_printer::{FormatBuilder, PrettyFormatter};

use rmcp::{
    RoleClient, ServiceExt,
    model::{ClientInfo, Resource, ResourceTemplate, Tool},
    service::RunningService,
    transport::TokioChildProcess,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
struct ServerInfo {
    service: String,
    version: String,
}
use syntect::easy::HighlightLines;
use syntect::highlighting::{Style, ThemeSet};
use syntect::parsing::SyntaxSet;
use syntect::util::{LinesWithEndings, as_24_bit_terminal_escaped};

#[derive(Debug, Deserialize, Serialize)]
struct McpToolParameter {
    required: Vec<String>,
    properties: IndexMap<String, Box<Schema>>,
}

/// MCP client for interacting with the SpecX MCP server
struct McpClient {
    skin: MadSkin, // Keep for backward compatibility
    highlight: Highlight,
    client: RunningService<RoleClient, ClientInfo>,
    tools: Vec<Tool>,
    resources: Vec<Resource>,
    templates: Vec<ResourceTemplate>,
    pretty: PrettyFormatter,
}

async fn build_stdio_client(url: &str) -> Result<RunningService<RoleClient, ClientInfo>> {
    let mut cmd = string_to_command(url);
    let process = TokioChildProcess::new(&mut cmd)?;
    let client_info = rmcp::model::ClientInfo::default();
    let client = client_info.serve(process).await.inspect_err(|e| {
        tracing::error!("client error: {:?}", e);
    })?;
    Ok(client)
}

async fn build_sse_client(url: &str) -> Result<RunningService<RoleClient, ClientInfo>> {
    let transport = rmcp::transport::SseTransport::start(url).await?;
    let client_info = rmcp::model::ClientInfo::default();
    let client = client_info.serve(transport).await.inspect_err(|e| {
        tracing::error!("client error: {:?}", e);
    })?;
    Ok(client)
}

impl McpClient {
    async fn new(
        client: RunningService<RoleClient, ClientInfo>,
        skin: MadSkin,
        highlight: Highlight,
    ) -> Result<Self> {
        let server_info = client.peer_info();
        tracing::info!("Connected to server: {server_info:#?}");

        // Check server capabilities to determine what methods are supported
        let server_capabilities = &server_info.capabilities;

        // Check if tools capability is supported
        let has_tools_capability = server_capabilities.tools.as_ref().is_some();

        // Check if resources capability is supported
        let has_resources_capability = server_capabilities.resources.as_ref().is_some();

        tracing::info!(
            "Server capabilities - Tools: {}, Resources: {}",
            has_tools_capability,
            has_resources_capability
        );

        // Only fetch tools if the server supports them
        let tools = if has_tools_capability {
            match client.list_all_tools().await {
                Ok(tools) => {
                    tracing::info!("Loaded tools: {tools:#?}");
                    tools
                }
                Err(e) => {
                    tracing::warn!("Failed to load tools despite capability: {e}");
                    Vec::new()
                }
            }
        } else {
            tracing::info!("Server does not support tools capability");
            Vec::new()
        };

        // Only fetch resources if the server supports them
        let (resources, templates) = if has_resources_capability {
            let resources = match client.list_all_resources().await {
                Ok(resources) => {
                    tracing::info!("Loaded resources: {resources:#?}");
                    resources
                }
                Err(e) => {
                    tracing::warn!("Failed to load resources despite capability: {e}");
                    Vec::new()
                }
            };

            let templates = match client.list_all_resource_templates().await {
                Ok(templates) => {
                    tracing::info!("Loaded templates: {templates:#?}");
                    templates
                }
                Err(e) => {
                    tracing::warn!("Failed to load templates despite capability: {e}");
                    Vec::new()
                }
            };

            (resources, templates)
        } else {
            tracing::info!("Server does not support resources capability");
            (Vec::new(), Vec::new())
        };

        Ok(Self {
            skin,
            client,
            tools,
            resources,
            templates,
            highlight,
            pretty: PrettyFormatter::new(),
        })
    }

    /// Refresh the list of available MCP tools
    async fn refresh_tools(&mut self) -> Result<()> {
        println!("DEBUG: Refreshing tools");

        // Check server capabilities before attempting to refresh tools
        let server_info = self.client.peer_info();
        let has_tools_capability = server_info.capabilities.tools.as_ref().is_some();

        if has_tools_capability {
            match self.client.list_all_tools().await {
                Ok(tools) => {
                    self.tools = tools;
                    println!("Successfully refreshed tools.");
                }
                Err(e) => {
                    println!("Failed to refresh tools despite capability: {e}");
                }
            }
        } else {
            println!("Server does not support tools capability, skipping refresh.");
        }

        Ok(())
    }

    /// Refresh the list of available MCP resources
    async fn refresh_resources(&mut self) -> Result<()> {
        // Check server capabilities before attempting to refresh resources
        let server_info = self.client.peer_info();
        let has_resources_capability = server_info.capabilities.resources.as_ref().is_some();

        if has_resources_capability {
            self.resources = self.client.list_all_resources().await?;

            match self.client.list_all_resource_templates().await {
                Ok(templates) => {
                    self.templates = templates;
                    println!("Successfully refreshed templates.");
                }
                Err(e) => {
                    println!("Failed to refresh templates despite capability: {e}");
                }
            }
        } else {
            println!("Server does not support resources capability, skipping refresh.");
        }

        Ok(())
    }

    fn print_info(&self) {
        // Create a header for the server info
        let doc = self
            .pretty
            .title("Server Information")
            .append(self.pretty.line());
        self.pretty.print(doc);

        // Get server info and format it
        let server_info = self.client.peer_info();
        let yaml_str = serde_yaml::to_string(&server_info)
            .unwrap_or_else(|_| "<error serializing>".to_string());

        // Apply syntax highlighting
        let highlighted = self.highlight.highlight("yaml", &yaml_str.trim());

        // Simply print the highlighted text - pretty printer doesn't handle pre-formatted text well
        println!("{}", highlighted);
    }

    fn print_header(&self, header: impl std::fmt::Display) {
        let doc = self.pretty.title(&header.to_string());
        self.pretty.print(doc);
    }

    fn print_tool(&self, tool: &Tool) {
        let pretty = &self.pretty;
        // Create a document with the tool name as a title
        let mut tool_doc = pretty.title(tool.name.to_string()).append(pretty.p(":"));

        // Add line break
        tool_doc = tool_doc.append(pretty.line());

        // Parse and format input schema parameters
        let schema: McpToolParameter = serde_json::from_value(serde_json::Value::Object(
            tool.input_schema.as_ref().clone(),
        ))
        .expect(&format!(
            "Failed to parse tool input schema: {}",
            serde_json::to_string(&tool.input_schema).unwrap()
        ));

        // Format parameters and their types
        let properties = schema.properties;
        if !properties.is_empty() {
            for (name, value) in properties {
                let mut param_doc = docs![
                    &pretty.alloc,
                    pretty.text(name.to_string()),
                    pretty.p(":"),
                    pretty.sp()
                ];

                // Add type information if available
                if let Schema::Object(schema_obj) = value.as_ref() {
                    if let Some(type_val) = schema_obj.instance_type.as_ref() {
                        param_doc = param_doc
                            .append(docs![
                                &pretty.alloc,
                                pretty.union(to_vec(type_val).iter().map(format_type), |ty| pretty
                                    .ty(ty))
                            ])
                            .indent(2);
                    }
                }

                // Add description if available
                if let Schema::Object(schema_obj) = value.as_ref() {
                    if let Some(desc) = &schema_obj
                        .metadata
                        .as_ref()
                        .and_then(|m| m.description.clone())
                    {
                        param_doc =
                            param_doc.append(self.pretty.text(format!(" - {}", desc.to_string())));
                    }
                }

                tool_doc = tool_doc.append(param_doc).append(self.pretty.line());
            }
        }

        // Add description if available
        if let Some(description) = &tool.description {
            tool_doc = tool_doc.append(docs![
                &pretty.alloc,
                pretty.line(),
                pretty.words(description.to_string()).indent(2),
                pretty.line(),
                pretty.line()
            ]);
        }

        // Print the formatted document
        self.pretty.print(tool_doc);
    }

    fn print_tools(&self) -> Result<()> {
        if self.tools.is_empty() {
            let doc = self.pretty.text("No tools available");
            self.pretty.print(doc);
        } else {
            for tool in &self.tools {
                self.print_tool(tool);
            }
        }
        Ok(())
    }

    fn print_resources(&self) -> Result<()> {
        self.print_list(self.resources.iter().map(|r| r.name.clone()));
        Ok(())
    }

    fn print_list(&self, items: impl IntoIterator<Item = impl std::fmt::Display>) {
        // Convert display items to strings
        let items = items
            .into_iter()
            .map(|item| item.to_string())
            .collect::<Vec<_>>();

        // Create a pretty-formatted list and print it
        let doc = self.pretty.list(&items);
        self.pretty.print(doc);
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let highlight = Highlight::new();

    let history = confy::get_configuration_file_path("mcp_repl", "history").unwrap();

    println!("History file: {}", history.display());

    let matches: ArgMatches = Command::new("MCP REPL Client")
        .version("0.1.0")
        .author("SpecX Team")
        .about("REPL client for the Model Context Protocol (MCP)")
        .arg(
            Arg::new("sse")
                .short('s')
                .long("sse")
                .value_name("URL")
                .help("URL of the MCP server (SSE)")
                .default_value("http://localhost:3000"),
        )
        .arg(
            Arg::new("stdio")
                .short('c')
                .long("stdio")
                .value_name("COMMAND")
                .help("Command to run (STDIO)")
                .required(false),
        )
        .get_matches();

    // Get server URL from command-line arguments
    let sse_url = matches.get_one::<String>("sse");
    let stdio_command = matches.get_one::<String>("stdio");

    let client = if let Some(command) = stdio_command {
        build_stdio_client(command).await?
    } else {
        build_sse_client(sse_url.unwrap()).await?
    };

    // Create MadSkin
    let mut skin = MadSkin::default();
    skin.bullet = StyledChar::from_fg_char(Color::Yellow, '⟡');
    skin.headers[1].add_attr(Attribute::Bold);
    skin.headers[1].set_fg(Color::Cyan);

    // Create and initialize the MCP client
    let mut client = McpClient::new(client, skin, highlight).await?;

    // Connect to the server and get basic info
    // println!("Session ID: {:#?}", client.client.peer_info().server_info);

    // Refresh tools and resources
    client.refresh_tools().await?;
    client.refresh_resources().await?;

    // Define and parse command-line arguments
    let mut repl: Repl<McpClient, Error> = Repl::new(client)
        .with_history(history, 1000)
        .with_name("MCP REPL Client")
        .with_version("0.1.0")
        .with_description("REPL client for the Model Context Protocol (MCP)")
        .with_command(Command::new("info"), |_, client| {
            client.print_info();
            Ok(None)
        })
        .with_command(
            Command::new("list")
                .arg(
                    Arg::new("type")
                        .value_parser(["tools", "resources"])
                        .next_line_help(true),
                )
                .about("List available tools or resources (default: both)"),
            |matches, client| {
                let matches = matches.get_one::<String>("type");
                match matches.map(|s| s.as_str()) {
                    Some("tools") => {
                        client.print_tools()?;
                    }
                    Some("resources") => {
                        client.print_resources()?;
                    }
                    None => {
                        client.print_header("[Tools]");
                        client.print_tools()?;
                        client.print_header("[Resources]");
                        client.print_resources()?;
                    }
                    _ => {
                        unreachable!();
                    }
                }
                Ok(None)
            },
        );

    repl.run_async().await?;

    Ok(())
}

struct Highlight {
    syntax: SyntaxSet,
    theme: ThemeSet,
}

impl Highlight {
    fn new() -> Self {
        Self {
            syntax: SyntaxSet::load_defaults_newlines(),
            theme: ThemeSet::load_defaults(),
        }
    }
    fn highlight(&self, ext: &str, text: &str) -> String {
        let syntax = self.syntax.find_syntax_by_extension(ext).unwrap();
        let mut h = HighlightLines::new(syntax, &self.theme.themes["Solarized (dark)"]);
        let mut buf = String::new();

        for line in LinesWithEndings::from(text) {
            // LinesWithEndings enables use of newlines mode
            let ranges: Vec<(Style, &str)> = h.highlight_line(line, &self.syntax).unwrap();
            let escaped = as_24_bit_terminal_escaped(&ranges[..], true);
            buf.push_str(&escaped);
        }

        termimad::crossterm::Command::write_ansi(&ResetColor, &mut buf).unwrap();
        buf
    }
}

fn pad_lines(input: &str, prefix: &str) -> String {
    let mut buf = String::new();
    for line in input.lines() {
        buf.push_str(prefix);
        termimad::crossterm::Command::write_ansi(&ResetColor, &mut buf).unwrap();
        buf.push_str(line);
        buf.push('\n');
    }
    buf
}

enum SchemaValidation {
    Number(schema::NumberValidation),
    String(schema::StringValidation),
    Array(schema::ArrayValidation),
    Object(schema::ObjectValidation),
    Enum(Vec<Value>),
    Const(Value),
    Subschema(schema::SubschemaValidation),
    None,
}

struct FormattedSchema<'a> {
    ty: Vec<InstanceType>,
    validation: SchemaValidation,
    format: Option<String>,
    pretty: &'a PrettyFormatter,
}

impl<'a> FormattedSchema<'a> {
    fn new(obj: &SchemaObject, pretty: &'a PrettyFormatter) -> Self {
        let ty: Vec<InstanceType> = match &obj.instance_type {
            Some(SingleOrVec::Single(ty)) => vec![*ty.clone()],
            Some(SingleOrVec::Vec(types)) => types.clone(),
            None => vec![InstanceType::Null],
        };

        let format = obj.format.clone();

        if let Some(validation) = &obj.number {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Number(*validation.clone()),
                pretty,
            };
        }

        if let Some(validation) = &obj.string {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::String(*validation.clone()),
                pretty,
            };
        }

        if let Some(validation) = &obj.array {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Array(*validation.clone()),
                pretty,
            };
        }

        if let Some(validation) = &obj.object {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Object(*validation.clone()),
                pretty,
            };
        }

        if let Some(validation) = &obj.enum_values {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Enum(validation.clone()),
                pretty,
            };
        }

        if let Some(validation) = &obj.const_value {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Const(validation.clone()),
                pretty,
            };
        }

        if let Some(subschemas) = &obj.subschemas {
            return FormattedSchema {
                ty,
                format,
                validation: SchemaValidation::Subschema(*subschemas.clone()),
                pretty,
            };
        }

        // Default case - no validation
        FormattedSchema {
            ty,
            validation: SchemaValidation::None,
            format,
            pretty,
        }
    }

    fn pretty(&self) -> FormatBuilder<'a> {
        let mut doc = self.pretty.alloc.nil().annotate(ColorSpec::new().clone());

        // Add type information
        doc = doc.append(
            self.pretty.text(
                self.ty
                    .iter()
                    .map(format_type)
                    .collect::<Vec<_>>()
                    .join(" | "),
            ),
        );
        match &self.validation {
            SchemaValidation::Number(validation) => {
                doc = doc.append(self.pretty.text(format!(
                    " ({})",
                    self.range_text(
                        validation
                            .exclusive_minimum
                            .or(validation.minimum)
                            .map(|v| v as usize),
                        validation.exclusive_minimum.is_some(),
                        validation
                            .exclusive_maximum
                            .or(validation.maximum)
                            .map(|v| v as usize),
                        validation.exclusive_maximum.is_some(),
                    )
                )));
            }
            SchemaValidation::String(validation) => {
                match (validation.min_length, validation.max_length) {
                    (None, None) => {}
                    (min, max) => {
                        doc = doc.append(self.pretty.text(format!(
                            " (size {})",
                            self.range_text(
                                min.map(|v| v as usize),
                                false,
                                max.map(|v| v as usize),
                                max.is_some(),
                            )
                        )));
                    }
                }
            }
            SchemaValidation::Array(validation) => {
                match (validation.min_items, validation.max_items) {
                    (None, None) => {}
                    (min, max) => {
                        doc = doc.append(self.pretty.text(format!(
                            " ({} items)",
                            self.range_text(
                                min.map(|v| v as usize),
                                false,
                                max.map(|v| v as usize),
                                max.is_some(),
                            )
                        )));
                    }
                }
            }
            SchemaValidation::Object(_validation) => {
                doc = doc.append(self.pretty.text(" object"));
            }
            SchemaValidation::Enum(values) => {
                doc = doc.append(self.pretty.text(format!(
                    " {}",
                    values
                        .iter()
                        .map(|value| format!("{}", value))
                        .collect::<Vec<_>>()
                        .join(" | ")
                )));
            }
            SchemaValidation::Const(value) => {
                doc = doc.append(self.pretty.text(format!(" {}", value)));
            }
            SchemaValidation::Subschema(_subschemas) => {
                doc = doc.append(self.pretty.text(" subschema"));
            }
            SchemaValidation::None => {}
        }

        if let Some(format) = &self.format {
            doc = doc.append(self.pretty.text(format!(
                " {}{} {}{}",
                p("("),
                kw("as").dim(),
                format.bright_blue(),
                p(")")
            )));
        }

        doc
    }

    fn range_text(
        &self,
        min: Option<usize>,
        exclusive_min: bool,
        max: Option<usize>,
        exclusive_max: bool,
    ) -> String {
        match (min, max) {
            (Some(min), Some(max)) => format!(
                "{}{}..{}{}",
                if exclusive_min { "(" } else { "[" },
                min,
                max,
                if exclusive_max { ")" } else { "]" },
            ),
            (Some(min), None) => format!("{}{}..∞)", if exclusive_min { "(" } else { "[" }, min),
            (None, Some(max)) => format!("-∞..{}{}", max, if exclusive_max { ")" } else { "]" }),
            (None, None) => "(-∞..∞)".to_string(),
        }
    }

    /// Format a SchemaObject with all its properties
    fn format_schema_object(&self, obj: &SchemaObject) -> FormatBuilder<'a> {
        FormattedSchema::new(obj, self.pretty).pretty()
    }

    fn format_properties(
        &self,
        McpToolParameter {
            properties,
            required,
        }: &McpToolParameter,
    ) -> FormatBuilder<'a> {
        let mut doc = self.pretty.alloc.nil().annotate(ColorSpec::new().clone());

        for (prop_name, prop_schema) in properties {
            let name_str = prop_name.to_string();
            // Add property name with formatting based on if it's required
            if required.contains(prop_name) {
                doc = doc.append(self.pretty.text(format!("{}{} ", name_str, p(":"))));
            } else {
                doc = doc.append(self.pretty.p(format!("[{}{} ", name_str, p(":"))));
            }

            // Use the appropriate FormattedSchema based on schema type
            match prop_schema.as_ref() {
                Schema::Bool(b) => {
                    doc = doc.append(self.pretty.text(b.to_string()));
                }
                Schema::Object(o) => {
                    // Use FormattedSchema to build the document
                    doc = doc.append(FormattedSchema::new(o, self.pretty).pretty());
                }
            };

            doc = doc.append(self.pretty.line());
        }

        doc
    }

    /// Format a JSON Schema into a readable string representation
    fn format_schema(&self, schema: &Schema) -> FormatBuilder<'a> {
        match schema {
            Schema::Bool(b) => self.pretty.text(b.to_string()),
            Schema::Object(o) => self.format_schema_object(o),
        }
    }
}

/// Format an instance type as a human-readable string
fn format_type(instance_type: &InstanceType) -> &'static str {
    match instance_type {
        InstanceType::Null => "null",
        InstanceType::Boolean => "boolean",
        InstanceType::Object => "object",
        InstanceType::Array => "array",
        InstanceType::Number => "number",
        InstanceType::String => "string",
        InstanceType::Integer => "integer",
    }
}

fn ty_style(s: &str) -> Painted<&str> {
    s.magenta()
}

fn p(s: &str) -> Painted<&str> {
    s.bright_black()
}

fn kw(s: &str) -> Painted<&str> {
    s.cyan()
}

fn string_to_command(cmd_str: &str) -> tokio::process::Command {
    let args = shell_words::split(cmd_str).expect("Failed to parse command string");
    if args.is_empty() {
        return std::process::Command::new("").into();
    }

    let mut cmd = std::process::Command::new(&args[0]);
    cmd.args(&args[1..]);
    cmd.into()
}

fn to_vec<T>(from: &SingleOrVec<T>) -> Vec<T>
where
    T: Clone,
{
    match from.clone() {
        SingleOrVec::Single(val) => vec![*val.clone()],
        SingleOrVec::Vec(val) => val.clone(),
    }
}
